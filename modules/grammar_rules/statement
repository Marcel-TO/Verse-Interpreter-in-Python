program: statement_list | func_decl (SEMI statement_list | func_decl)*?


block: statement_list
statement_list: statement (SEMI statement)*?                                  --> SEMI means ;
statement: expr|if|for|func_call


func_call: IDENTIFIER LB (func_call_args)? RB                                

func_call_args: expr (COMMA expr)*?                                          --> COMMA means ,

func_decl: IDENTIFIER LB func_dec_param RB (COLON type)? BINDING block
          |IDENTIFIER BINDING LB nested_scope LAMBDA expr RB                  --> LAMBDA means =>         Maybe instead of expr use statement_list

func_dec_param: nested_scope


if_statement: IF LB expr RB ((THEN block ELSE block) | (THEN CBL expr CBR ELSE CBL expr CBR))    --> THEN means then; ELSE means else


for_loop: FOR LCB (scope|expr) (;expr)*? RCB                                  --> LCB/RCB means (LEFT/RIGHT) CURVY BRACKETS; FOR means for
    |FOR LB (scope|expr) (,expr)*? RB DO expr


nested_scope: Identifier (,Identifier)*? COLON TYPE


sequence: LB expr (COMMA expr)* RB                  --> tuple
         array {expr (COMMA expr)*}                 --> array

      













--------------MAY NEED TO BE NEEDED------------------
statement: assign_statement               
                
        
statement_block: func_decl
                 



assign_statement: binding_statement EQ (method_call|expr)           =
binding_statement: scope_statement BINDING (method_call|expr)       :=
scope_statement: IDENTIFIER (,IDENTIFIER)*? COLON TYPE              :

